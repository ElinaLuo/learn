# 浏览器多线程

每个标签页通常：
- 1个JS主线程
- 1个GUI渲染线程  
- 1个事件线程
- 1个定时器线程
- 多个网络线程（通常6-8个并发）
- 多个Worker线程（根据需要创建）


1.GUI渲染线程 -- “装修工”
角色：负责页面的“面子”工程

作用：
- 解析HTML → 构建DOM树
- 解析CSS → 构建CSSOM树
- 结合DOM和CSSOM → 渲染树(Render Tree)
- 布局(Layout) → 确定每个元素的尺寸和位置
- 绘制(Painting) → 填充像素
- 合成(Compositing) → 图层合并

理想的绘制频率：理想的绘制频率取决于设备，大多数显示器以60次/秒(60hz) 的频率刷新屏幕，也就是每隔16.6ms绘制一次屏幕。也有些高刷新率显示器可以达到120hz或144hz的刷新率
实际的绘制频率：不固定，在事件循环在清空所有的微任务后 且 当页面有 DOM 或样式变化时，浏览器才会重绘。当低于理想绘制频率时，肉眼会感觉到卡顿，也就是出现了“丢帧”。

特别注意：他和下面的“JS 工程师”是死对头。因为 JS 可能会修改页面样式，如果两人同时动手，页面就乱套了。所以，当 JS 工程师工作时，装修工会被强制休息（挂起）

2.JS引擎线程 -- “逻辑总管”
角色：负责页面的“脑子”，也就是大名鼎鼎的 JavaScript 引擎（如 Chrome 的 V8）

作用：
- 单线程执行（“单核大脑”）：一次只能执行一个任务
- 执行所有JS代码：同步、异步回调、事件处理
- 管理调用栈：函数调用、执行上下文

特别注意：如果 JS 写的代码太复杂、计算时间太长，他就会一直霸占着控制权。导致旁边的“装修工”无法干活，页面就会出现卡顿或假死的现象

3.事件触发线程
角色： 负责管理用户的操作和任务队列。

作用：
- 事件的调度中心和协调者，包含的事件：用户交互(click、scroll等)、网络响应(XMLHttpRequest、fetch等)、定时器(setTimeout、setIntervel等)、history变化、文件读取等
- 管理事件执行的优先级：确保用户交互优先
- 通知JS线程：唤醒JS线程处理待执行的事件

4.定时器线程
角色： 专门负责 setTimeout 和 setInterval 这种定时任务。

作用：
- 管理定时器：维护setTimeout/setInterval
- 计时功能：精确计时，不受JS阻塞影响
- 回调排队：时间到时将回调加入宏任务中

5.HTTP网络线程
角色： 负责向服务器拿数据（Ajax 请求）。

作用：
- 处理网络请求：XMLHttpRequest、Fetch API，当监听到状态变更，fetc会将回调放到微任务队列中（因为fetch是基于Promise实现的），XMLHttpRequest、webSocket会放到宏任务中
- 并发请求：浏览器限制（同一域名6-8个并发）
- 不阻塞页面：网络IO在独立线程进行

6.Web Workder
使用场景：大数据处理、图像/视频处理、复杂计算、加密解密等
特点：
- 独立线程：不阻塞主线程
- 无法访问DOM：与渲染线程隔离
- 通过消息通信：postMessage/onmessage

7.Service Worker
特殊的Web Workder
作用：
- 网络代理：拦截和处理网络请求
- 离线支持：缓存资源，离线访问
- 后台同步：数据同步

8.合成线程
现代浏览器优化
作用：
- 图层管理：将页面分成多个图层
- GPU加速：利用显卡处理动画
- 滚动优化：独立处理滚动，流畅体验
