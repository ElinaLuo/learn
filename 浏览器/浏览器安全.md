
# XSS
cross-site scripting 跨站脚本攻击，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全

前端安全系列（一）：如何防止XSS攻击？
https://juejin.cn/post/6844903685122703367?searchId=20251230190826DC4356920C0DCF0D7793

分类：
1.反射性XSS
反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站

2.存储型XSS
存储型 XSS 会把用户输入的数据 "存储" 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。大多为评论、留言板、聊天等场景

3.基于DOM的XSS
基于 DOM 的 XSS 攻击是攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站，与反射性 XSS 攻击方式不同的是，反射性需要经过服务器，而在DOM型攻击中，取出和执行恶意代码都是由纯浏览器端完成

预防：
1.输入校验，非法字符校验
2.输出处理（转义），使用js-xss库，现代框架如Vue/React等会自动转义
3.使用安全的DOM API，如innerText，避免使用v-html/dangerouslySetInnerHTML功能
4.开启CSP(Content Security Policy)
  CSP可以指定白名单，如script-src（可执行脚本）、img-src（图片资源）、frame-src（iframe）等等
  CSP可以禁用执行内联 <script> 块、内联事件、javascript: 伪协议 URL等，也可以通过script-src 'unsafe-inline' 取消该行为
5.Cookie开启httpOnly，攻击js就无法访问document.cookie：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Guides/CSP
6.主动检测和发现：自动扫描工具寻找潜在的 XSS 漏洞

# CSRF
cross-site request forgery 跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的

预防：
1.来源检测，检查request header中Origin或Referer是否来自可信域名
2.Token验证（此种方法在遇到XSS攻击时失效）
  流程如下：
  java收到用户请求，首次根据uuid或加密算法生成token，并存在当前用户的HttpSession中
  前端提交时携带 Token
  服务器验证 Token 是否一致
3.双重Cookie验证，比如验证码或交易密码
4.cookie的sameSite属性，设置为Strict或Lax，如果设置为Lax，则后端接口不要在GET请求中进行数据处理

前端安全系列之二：如何防止CSRF攻击？
https://juejin.cn/post/6844903689702866952?searchId=20260112195504B141B3215AE7B0AB23FF

扩展：
java是怎么识别这是同一个session的请求呢？
第一次生成session时，java会生成一个sessionId，通过set-cookie返回给客户端，客户端下次请求时，会将sessionId通过cookie带上，服务器收到请求后，会根据sessionId找到对应的session


XSS与CSRF区别
XSS核心是代码注入，类比小偷已经进入到家里了，然后就可以盗窃
CSRF核心是伪造用户请求，类比小偷已经拿到用户的卡了，然后就可以盗刷
XSS相比CSRF更危险，一旦网站存在 XSS 漏洞，CSRF 防御机制通常会瞬间失效
