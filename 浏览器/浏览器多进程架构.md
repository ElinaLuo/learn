# 浏览器多进程架构

进程和线程区别：
进程是操作系统进行资源分配（内存、CPU时间片）的最小单位，拥有独立的内存空间，进程间通信难度高（通过IPC），一旦崩溃其它进程不受影响
线程是操作系统进行运算调度（CPU执行）的最小单位，同一个进程中的线程共享数据，线程间通信容易

IPC，全称Inter-Process Communication

Chrome内部运作机制（总共4篇）：
[深入了解现代网络浏览器](https://developer.chrome.com/blog/inside-browser-part1?hl=zh-cn)

以Chrome浏览器为例，其它游览器可能不太一样

## 核心进程（通常只有一个）

- Browser Process（浏览器主进程）：控制应用的“Chrome”部分，包括地址栏、书签、返回和前进按钮
- GPU Process（GPU 进程）：隔离地处理 GPU 任务，不受其他进程的影响。它会分隔到不同的进程中，因为 GPU 会处理来自多个应用的请求，并在同一 Surface 中绘制这些请求。
- Netword Process（网络进程）：负责网络资源加载（DNS、TCP、HTTP/3 等）
  - 处理网络请求：XMLHttpRequest、Fetch API，当监听到状态变更，fetc会将回调放到微任务队列中（因为fetch是基于Promise实现的），XMLHttpRequest、webSocket会放到宏任务中
  - 并发请求：浏览器限制（同一域名6-8个并发）
  - 不阻塞页面：网络IO在独立进程中进行


## 与 Tab 强相关的进程

- Renderer Process（渲染进程）：控制显示网站的标签页中的所有内容
  - 尽可能为每个Tab分配一个渲染进程，好处：进程隔离，某个tab无响应其它tab仍然可以正常运行，缺点：内存用量会增加，因为进程有自己的私有内存空间，因此它们通常包含常用基础架构的副本（例如 Chrome 的 JavaScript 引擎 V8）
- Extension Process（扩展进程 - 如果有）：如果你的页面里运行了 Chrome 插件（比如广告拦截器、Vue DevTools），每个插件通常都有独立的进程


## Renderer Process（渲染进程）包含的线程

- Main Thread（主线程）
  这是最忙碌的线程，我们常说的“单线程”指的就是它。它身兼数职（我们从功能上划分的js引擎线程、GUI渲染线程、事件触发线程、定时器线程，其实都被合并在主线程了）：
  - 执行 JavaScript： V8 引擎运行的地方。
  - 解析 HTML/CSS： 构建 DOM 树和 CSSOM 树。
  - 计算布局 (Layout)： 计算元素的位置和大小。
  - 绘制记录 (Paint)： 此时不像素化，只是生成绘制指令列表。
  - 互斥关系： JS 执行和页面渲染（布局/绘制）是互斥的，JS 跑太久，页面就不动了。
- Compositor Thread（合成线程）
  这是 Chrome 性能优化的关键。专门处理滚动和 CSS 动画。它不占用主线程。即使主线程卡死（JS 死循环），合成线程依然能让页面滚动（虽然可能内容还没渲染出来，但能滚）
  作用： 负责接收用户的滚动、缩放操作。
  为什么快？ 它不直接运行 JS。当你滚动页面时，如果页面不需要重绘（比如没有复杂的 JS 动画），合成线程可以直接移动图层，不需要等待主线程。
  这就是为什么有时候 JS 卡死了（主线程堵塞），你依然可以滚动页面的原因。
- Raster Threads（光栅化线程池）—— 填色工
  作用： 主线程生成了“绘制指令”，合成线程把页面分成了很多“图块（Tiles）”。光栅化线程负责把这些图块转换成位图（Bitmap），也就是真正的像素。
  机制： 通常有多个光栅化线程在并行工作，利用 GPU 加速生成位图。
- IO Thread（IO 线程）—— 通讯员
  作用： 专门负责和浏览器主进程、网络进程进行通信（IPC）。
  流程： 网络进程下载完资源，通过 IPC 发给 IO 线程，IO 线程再转发给主线程处理。
- DedicatedWorker / ServiceWorker Threads（如果有）
  如果你在 JS 代码里使用了 new Worker() 或者注册了 Service Worker，浏览器会把它们开在独立的线程里，不阻塞主线程。
  
  Web Worker
  使用场景：大数据处理、图像/视频处理、复杂计算、加密解密等
  特点：

  - 独立线程：不阻塞主线程
  - 无法访问DOM：与渲染线程隔离
  - 通过消息通信：postMessage/onmessage

  Service Worker
  特殊的Web Workder
  作用：

  - 网络代理：拦截和处理网络请求
  - 离线支持：缓存资源，离线访问
  - 后台同步：数据同步



## Renderer Process（渲染进程）从功能上逻辑划分为如下线程

实际GUI渲染线程、JS引擎线程、定时器线程、事件触发线程在Chrome浏览器中被合并到Main Thread（主线程）中了，这里分开讲解仅仅只是为了理解主线程具体的作用

1.GUI渲染线程 -- “装修工”
角色：负责页面的“面子”工程

作用：

- 解析HTML → 构建DOM树
- 解析CSS → 构建CSSOM树
- 结合DOM和CSSOM → 渲染树(Render Tree)
- 布局(Layout) → 确定每个元素的尺寸和位置
- 绘制(Painting) → 填充像素
- 合成(Compositing) → 图层合并

理想的绘制频率：理想的绘制频率取决于设备，大多数显示器以60次/秒(60hz) 的频率刷新屏幕，也就是每隔16.6ms绘制一次屏幕。也有些高刷新率显示器可以达到120hz或144hz的刷新率
实际的绘制频率：不固定，在事件循环在清空所有的微任务后 且 当页面有 DOM 或样式变化时，浏览器才会重绘。当低于理想绘制频率时，肉眼会感觉到卡顿，也就是出现了“丢帧”。

特别注意：他和下面的“JS 工程师”是死对头。因为 JS 可能会修改页面样式，如果两人同时动手，页面就乱套了。所以，当 JS 工程师工作时，装修工会被强制休息（挂起）

2.JS引擎线程 -- “逻辑总管”
角色：负责页面的“脑子”，也就是大名鼎鼎的 JavaScript 引擎（如 Chrome 的 V8）

作用：

- 单线程执行（“单核大脑”）：一次只能执行一个任务
- 执行所有JS代码：同步、异步回调、事件处理
- 管理调用栈：函数调用、执行上下文

特别注意：如果 JS 写的代码太复杂、计算时间太长，他就会一直霸占着控制权。导致旁边的“装修工”无法干活，页面就会出现卡顿或假死的现象

3.事件触发线程
角色： 负责管理用户的操作和任务队列。

作用：

- 事件的调度中心和协调者，包含的事件：用户交互(click、scroll等)、网络响应(XMLHttpRequest、fetch等)、定时器(setTimeout、setIntervel等)、history变化、文件读取等
- 管理事件执行的优先级：确保用户交互优先
- 通知JS线程：唤醒JS线程处理待执行的事件

4.定时器线程
角色： 专门负责 setTimeout 和 setInterval 这种定时任务。

作用：

- 管理定时器：维护setTimeout/setInterval
- 计时功能：精确计时，不受JS阻塞影响
- 回调排队：时间到时将回调加入宏任务中

6.Web Workder
使用场景：大数据处理、图像/视频处理、复杂计算、加密解密等
特点：

- 独立线程：不阻塞主线程
- 无法访问DOM：与渲染线程隔离
- 通过消息通信：postMessage/onmessage

7.Service Worker
特殊的Web Workder
作用：

- 网络代理：拦截和处理网络请求
- 离线支持：缓存资源，离线访问
- 后台同步：数据同步
